<html>
	<head>
		<style>
			:root {
				user-select: none;
				background: black;
				scrollbar-width: none;
			}
			body {
				margin: 0;
				display: flex;
				flex-wrap: wrap;
			}

			.image-container {
				position: relative;
				vertical-align: top;
				float: left;
			}

			.image-container:hover .btn-hide {
				display: unset;
			}
			.btn-hide {
				display: none;
				position: absolute;
				top: 8px;
				right: 8px;
			}

			.image-container:hover .prompt-container {
				display: unset;
			}
			.prompt-container {
				display: none;
				position: absolute;
				top: 0px;
				left: 0px;
				margin: 8px;
				width: calc(100% - 16px);
				font-size: large;
				background-color: aliceblue;
				opacity: 75%;
			}
			.prompt-item {
				margin-top: 18px;
				margin-left: 18px;
				margin-right: 18px;
			}
			.prompt-item>p {
				margin-top: 0;
				user-select: text;
			}

			#settings {
				position: fixed;
				bottom: 0px;
				right: 0px;
				background: white;
				margin: 0;
				padding: 4px;
				opacity: 0;
			}
			#settings:hover {
				opacity: 1;
			}
			#settings fieldset {
				border-width: 0;
				border-top-width: unset;
				padding-left: 0;
				padding-right: 0;
				padding-bottom: 0;
			}
			#settings fieldset legend {
				margin-left: 12;
			}

			.hidden {
				display: none;
			}
		</style>
		<script type="text/javascript">
			'use strict'
			function onload(){
				function refreshHistory(){
					fetch('/history').then(response=>response.json()).then(result => {
						const historyKeys = Object.keys(result);
						for (const keyResult of Object.keys(result)) {
							const history = result[keyResult];
							for (const keyOutputs of Object.keys(history.outputs)) {
								const output = history.outputs[keyOutputs];
								let index = 0;
								for (const keyImages of Object.keys(output.images)) {
									const imageResult = output.images[keyImages];
									if(imageResult.type === 'temp'){
										continue;
									}
									const animated = output.animated ? output.animated[index++] : false;
									let imageURL = '/view?filename='+imageResult['filename']+'&animated='+animated;
									for (const i of document.body.childNodes) {
										if(images.find(i => i.src === imageURL)){
											imageURL = null;
											break;
										}
									}
									if(imageURL){
										const start = history.status.messages.find(m => m[0] === 'execution_start')[1].timestamp;
										const done = history.status.messages.find(m => m[0] === 'execution_success')[1].timestamp;
										executionTime += done - start;
										let uptime = ''; // Lookup: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/Duration
										const time = new Date(executionTime);
										const hours = time.getUTCHours();
										if(hours){
											uptime += hours.toString().padStart(2, '0')+':';
										}
										const minutes = time.getUTCMinutes();
										if(hours && minutes){
											uptime += minutes.toString().padStart(2, '0')+':';
										}
										document.getElementById('spnExecutionTime').innerText = uptime + time.getUTCSeconds().toString().padStart(2, '0');
										if(!startUpTime){
											startUpTime = start
										}
										const imageContainer = document.createElement('div');
										imageContainer.id = 'container-'+imageURL;
										imageContainer.classList.add('image-container');
										const image = new Image();
										images.push(image);
										const promptContainer = document.createElement('div');
										promptContainer.classList.add('prompt-container');
										imageContainer.appendChild(promptContainer);
										let promptItem = document.createElement('div');
										promptItem.classList.add('prompt-item');
										const lblCount = document.createElement('div');
										promptContainer.appendChild(promptItem);
										lblCount.classList = 'count';
										promptItem.appendChild(lblCount);
										for(const prompt of history.prompt){
											if(typeof prompt === 'object'){
												for (const keyPrompt of Object.keys(prompt)){
													const p = prompt[keyPrompt];
													if(p.class_type === 'CLIPTextEncode' && p.inputs.text.trim()){
														promptItem = document.createElement('div');
														promptItem.classList.add('prompt-item');
														promptContainer.appendChild(promptItem);
														let paragraph = document.createElement('label');
														paragraph.innerText = 'Prompt '+keyPrompt;
														promptItem.appendChild(paragraph);
														paragraph = document.createElement('p');
														let code = document.createElement('code');
														code.innerText = p.inputs.text
														paragraph.appendChild(code);
														promptItem.appendChild(paragraph);
													}
												}
											}
										}
										image.src = imageURL;
										image.onload = ()=>{
											const width = image.width;
											const height = image.height;
											secretCanvas.width = width;
											secretCanvas.height = height;
											const canvasContext = secretCanvas.getContext('2d');
											canvasContext.drawImage(image, 0, 0);
											const key = imageContainer.innerHTML+'-x'+width+'y'+height;
											if(!imageSum[key]){
												imageSum[key] = {count: 0, sum: [], data: [], width, height, html: imageContainer.innerHTML};
												document.getElementById('spnNumberOfImages').innerText = Object.keys(imageSum).length;
											}
											imageSum[key].count++;
											const data = [];
											imageSum[key].data.push(data);
											canvasContext.getImageData(0, 0, width, height).data.forEach((v, i) => {
												data.push(v);
												if(!imageSum[key].sum[i]){
													imageSum[key].sum[i] = 0;
												}
												imageSum[key].sum[i] += v;
											});
											updateMerge(key);
											sortMerge();
										}
										image.onerror = ()=>{
											imageContainer.classList.add('hidden');
										};
									}
								}
							}
						}
					}).finally(()=>{
						requestAnimationFrame(refreshHistory);
					});
				}
				let wheelEvent_change = 0;
				function helpers(){
					requestAnimationFrame(helpers);
					if(startUpTime){
						let uptime = ''; // Lookup: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/Duration
						const time = new Date(Date.now() - startUpTime);
						const hours = time.getUTCHours();
						if(hours){
							uptime += hours.toString().padStart(2, '0')+':';
						}
						const minutes = time.getUTCMinutes();
						if(hours && minutes){
							uptime += minutes.toString().padStart(2, '0')+':';
						}
						document.getElementById('spnUpTime').innerText = uptime + time.getUTCSeconds().toString().padStart(2, '0');
					}
					// Scroll service
					if(!wheelEvent_change || !inputScrollToNextImage.checked || Date.now() < wheelEvent_time + 500){
						return;
					}
					const tops = {};
					for(const imageContainer of document.getElementsByClassName('image-container')){
						const top = imageContainer.getBoundingClientRect().top;
						tops[top] = imageContainer;
					}
					const keys = Object.keys(tops);
					for(const t of keys){
						const ic = tops[t];
						if(0 < parseFloat(t) + ic.offsetHeight/2){
							const index = keys.indexOf(t) + wheelEvent_change;
							let imageContainer = tops[keys[index]];
							if(!imageContainer){
								imageContainer = tops[wheelEvent_change < 0 ? keys[0] : keys[keys.length-1]];
							}
							wheelEvent_change = 0;
							imageContainer.scrollIntoView({behavior: 'smooth'});
							break;
						}
					}
				}
				function median(list){
					list = list.toSorted();
					const n = list.length;
					if(n % 2){
						return list[(n-1)/2];
					}
					return (list[n/2-1]+list[n/2])/2;
				}
				function updateMerge(key){
					const data = imageSum[key];
					if(data.count < 2){
						return;
					}
					let canvas = document.getElementById(key);
					if(!canvas){
						canvas = document.createElement('canvas');
						const imageContainer = document.createElement('div');
						imageContainer.classList.add('image-container');
						imageContainer.innerHTML += data.html;
						imageContainer.appendChild(canvas);
						canvas.id = key;
						canvas.classList.add('average-image');
						canvas.width = data.width;
						canvas.height = data.height;
						document.body.prepend(imageContainer);
						resize(canvas);
					}
					const lblCount = canvas.parentElement.getElementsByClassName('count')[0];
					lblCount.innerText = 'Count: '+data.count;
					const canvasContext = canvas.getContext('2d');
					const imageData = canvasContext.createImageData(data.width, data.height);
					const length = data.data[0].length;
					let array = [];
					switch(inputMergeType.selectedOptions[0].value){
						case 'Average':
							array = data.sum.map(v => v/data.count);
							break
						case 'Median':
							for(let j = 0; j < length; j++){
								const list = [];
								imageSum[key].data.forEach((d) => {
									list.push(d[j]);
								});
								array.push(median(list));
							}
							break
						case 'Average of most common':
							for(let j = 0; j < length; j++){
								const list = [];
								imageSum[key].data.forEach((d) => {
									list.push(d[j]);
								});
								const obj = Object.groupBy(list, v => v);
								let max = 0;
								const values = [];
								const objKey = Object.keys(obj);
								for(const k of objKey){
									const v = obj[k].length;
									if(max < v){
										max = v;
										values.splice(0, values.length);
									}
									if(max == v){
										values.push(parseInt(k));
									}
								}
								array.push(values.reduce((acc, v) => acc + v, 0)/values.length);
							}
							break
						case 'Median of most common':
							for(let j = 0; j < length; j++){
								const list = [];
								imageSum[key].data.forEach((d) => {
									list.push(d[j]);
								});
								const obj = Object.groupBy(list, v => v);
								let max = 0;
								const values = [];
								const objKey = Object.keys(obj);
								for(const k of objKey){
									const v = obj[k].length;
									if(max < v){
										max = v;
										values.splice(0, values.length);
									}
									if(max == v){
										values.push(parseInt(k));
									}
								}
								array.push(median(values));
							}
							break
					}
					imageData.data.set(new Uint8ClampedArray(array));
					canvasContext.putImageData(imageData, 0, 0);
				}
				function sortMerge(){
					const keys = Object.keys(imageSum);
					let max = 0;
					for(const key of keys){
						max = Math.max(imageSum[key].count, max);
					}
					for(const key of keys){
						const data = imageSum[key];
						const canvas = document.getElementById(key);
						if(canvas){
							canvas.parentElement.style.order = -(inputInvertSort.checked ? max - data.count + 1 : data.count);
						}
					}
				}
				function resizeAll(){
					[...document.getElementsByClassName('average-image')].filter(i => !i.classList.contains('hidden')).map(resize);
				}
				function resize(canvas){
					const multiplier = inputImageWidth.valueAsNumber;
					const imageStyle = getComputedStyle(canvas);
					const zoom = document.body.clientWidth / (canvas.offsetWidth*multiplier);
					canvas.style.zoom = zoom;
				}
				function inputChange(event){
					localStorage.setItem('inputScrollToNextImage', inputScrollToNextImage.checked);
					localStorage.setItem('inputInvertSort', inputInvertSort.checked);
					localStorage.setItem('inputImageWidth', inputImageWidth.valueAsNumber);
					localStorage.setItem('inputSplashPrompt', inputSplashPrompt.valueAsNumber);
					resizeAll();
					for(const key of Object.keys(imageSum)){
						updateMerge(key);
					}
					sortMerge();
				}
				let startUpTime;
				let executionTime = 0;
				const images = [];
				const imageSum = {};
				let v;
				const secretCanvas = document.getElementById('secret-canvas');
				const inputScrollToNextImage = document.getElementById('inputScrollToNextImage');
				inputScrollToNextImage.addEventListener('change', inputChange);
				inputScrollToNextImage.checked = [null, 'true'].includes(localStorage.getItem('inputScrollToNextImage'));
				const inputInvertSort = document.getElementById('inputInvertSort');
				inputInvertSort.addEventListener('change', sortMerge);
				inputInvertSort.checked = ['true'].includes(localStorage.getItem('inputInvertSort'));
				const inputSplashPrompt = document.getElementById('inputSplashPrompt');
				inputSplashPrompt.addEventListener('change', inputChange);
				v = parseFloat(localStorage.getItem('inputSplashPrompt'));
				if(isNaN(v)){
					v = 3;
				}
				inputSplashPrompt.valueAsNumber = v;
				const inputImageWidth = document.getElementById('inputImageWidth');
				inputImageWidth.addEventListener('change', inputChange);
				v = parseInt(localStorage.getItem('inputImageWidth'));
				if(isNaN(v)){
					v = 3;
				}
				inputImageWidth.valueAsNumber = v;
				const inputGroupBy = document.getElementById('inputGroupBy');
				inputGroupBy.addEventListener('change', inputChange);
				const inputMergeType = document.getElementById('inputMergeType');
				inputMergeType.addEventListener('change', inputChange);
				inputChange();
				addEventListener('dblclick', mouseEvent => {
					if(!['BODY', 'CANVAS'].includes(mouseEvent.srcElement.tagName)){
						return;
					}
					if(!document.fullscreenElement){
						document.documentElement.requestFullscreen();
					}else if(document.exitFullscreen){
						document.exitFullscreen();
					}
				});
				addEventListener('resize', resizeAll);
				requestAnimationFrame(refreshHistory);
				requestAnimationFrame(helpers);
			}
		</script>
	</head>
	<body onload="onload()">
		<canvas id="secret-canvas" class="hidden"></canvas>
		<form id="settings">
			<div>
				<label for="inputImageWidth">
					Images per row:
				</label>
				<input id="inputImageWidth" name="Image width" type="number" step="any" min="1"/>
			</div>
			<div>
				<label for="inputScrollToNextImage">
					Scroll to next image:
				</label>
				<input id="inputScrollToNextImage" name="Scroll to next image" type="checkbox"/>
			</div>
			<div>
				<label for="inputInvertSort">
					Invert image sorting:
				</label>
				<input id="inputInvertSort" name="Invert image sorting" type="checkbox"/>
			</div>
			<div>
				<label for="inputSplashPrompt">
					Splash prompt (seconds):
				</label>
				<input id="inputSplashPrompt" name="Splash prompt" type="number" step="any" min="0"/>
			</div>
			<div>
				<label for="inputGroupBy">
					Group by:
				</label>
				<select id="inputGroupBy" name="Group by">
					<option>Prompt</option>
					<option>Seed</option>
				</select>
			</div>
			<div>
				<label for="inputMergeType">
					Merge type:
				</label>
				<select id="inputMergeType" name="Merge type">
					<option>Average</option>
					<option>Median</option>
					<option>Average of most common</option>
					<option>Median of most common</option>
				</select>
			</div>
			<fieldset>
				<legend>
					Information
				</legend>
				<div>
					<label for="spnNumberOfImages">
						Number of images:
					</label>
					<span id="spnNumberOfImages"></span>
				</div>
				<div>
					<label for="spnUpTime">
						Up-time:
					</label>
					<span id="spnUpTime"></span>
				</div>
				<div>
					<label for="spnExecutionTime">
						Execution time:
					</label>
					<span id="spnExecutionTime"></span>
				</div>
			</fieldset>
		</form>
	</body>
</html>
